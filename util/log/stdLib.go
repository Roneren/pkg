// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package log

// Most of this code can be improved to fits the needs for others.
// Main reason for implementing this was to provide a basic leveled logger without
// any dependencies to third party packages.

import (
	"bytes"
	"fmt"
	"io"
	std "log"
	"os"

	"github.com/corestoreio/csfw/util/bufferpool"
	"github.com/corestoreio/csfw/util/errors"
)

const (
	StdLevelFatal int = iota + 1
	StdLevelInfo
	StdLevelDebug
)

// StdLog implements logging with Go's standard library
type StdLog struct {
	gw    io.Writer // global writer
	level int
	flag  int // global flag http://golang.org/pkg/log/#pkg-constants
	debug *std.Logger
	info  *std.Logger
	fatal *std.Logger
}

// StdOption can be used as an argument in NewStdLog to configure a standard logger.
type StdOption func(*StdLog)

// NewStdLog creates a new logger with 6 different sub loggers.
// You can use option functions to modify each logger independently.
// Default output goes to Stderr.
func NewStdLog(opts ...StdOption) *StdLog {
	sl := &StdLog{
		level: StdLevelInfo,
		gw:    os.Stderr,
		flag:  std.LstdFlags,
	}
	for _, o := range opts {
		o(sl)
	}
	if sl.debug == nil {
		sl.debug = std.New(sl.gw, "DEBUG ", sl.flag)
	}
	if sl.info == nil {
		sl.info = std.New(sl.gw, "INFO ", sl.flag)
	}
	if sl.fatal == nil {
		sl.fatal = std.New(sl.gw, "FATAL ", sl.flag)
	}
	return sl
}

// SetStdWriter sets the global writer for all loggers. This global writer can be
// overwritten by individual level options.
func WithStdWriter(w io.Writer) StdOption {
	return func(l *StdLog) {
		l.gw = w
	}
}

// WithStdFlag sets the global flag for all loggers.
// These flags define which text to prefix to each log entry generated by the Logger.
// This global flag can be overwritten by individual level options.
// Please see http://golang.org/pkg/log/#pkg-constants
func WithStdFlag(f int) StdOption {
	return func(l *StdLog) {
		l.flag = f
	}
}

// WithStdLevel sets the log level. See constants Level*
func WithStdLevel(level int) StdOption {
	return func(l *StdLog) {
		l.SetLevel(level)
	}
}

// WithStdDebug applies options for debug logging
func WithStdDebug(out io.Writer, prefix string, flag int) StdOption {
	return func(l *StdLog) {
		l.debug = std.New(out, prefix, flag)
	}
}

// WithStdInfo applies options for info logging
func WithStdInfo(out io.Writer, prefix string, flag int) StdOption {
	return func(l *StdLog) {
		l.info = std.New(out, prefix, flag)
	}
}

// WithStdFatal applies options for fatal logging
func WithStdFatal(out io.Writer, prefix string, flag int) StdOption {
	return func(l *StdLog) {
		l.fatal = std.New(out, prefix, flag)
	}
}

// New returns a new Logger that has this logger's context plus the given context
// This function panics if an argument is not of type StdOption.
func (l *StdLog) New(iOpts ...interface{}) Logger {
	var opts = make([]StdOption, len(iOpts), len(iOpts))
	for i, iopt := range iOpts {
		if o, ok := iopt.(StdOption); ok {
			opts[i] = o
		} else {
			panic("Arguments to New() can only be StdOption types!")
		}
	}
	return NewStdLog(opts...)
}

// Debug logs a debug entry.
func (l *StdLog) Debug(msg string, fields ...Field) {
	l.log(StdLevelDebug, msg, fields)
}

// Info logs an info entry.
func (l *StdLog) Info(msg string, fields ...Field) {
	l.log(StdLevelInfo, msg, fields)
}

// Fatal logs a fatal entry then panics.
func (l *StdLog) Fatal(msg string, fields ...Field) {
	l.log(StdLevelFatal, msg, fields)
}

// log logs a leveled entry. Panics if an unknown level has been provided.
func (l *StdLog) log(level int, msg string, fs Fields) {
	if l.level >= level {
		switch level {
		case StdLevelDebug:
			// l.debug.Print(stdFormat(msg, append(args, "in", getStackTrace())))
			l.debug.Print(stdFormat(msg, fs))
			break
		case StdLevelInfo:
			l.info.Print(stdFormat(msg, fs))
			break
		case StdLevelFatal:
			l.fatal.Panic(stdFormat(msg, fs))
			break
		default:
			panic("Unknown Log Level")
		}
	}
}

// IsDebug determines if this logger logs a debug statement.
func (l *StdLog) IsDebug() bool { return l.level >= StdLevelDebug }

// IsInfo determines if this logger logs an info statement.
func (l *StdLog) IsInfo() bool { return l.level >= StdLevelInfo }

// SetLevel sets the level of this logger.
func (l *StdLog) SetLevel(level int) {
	l.level = level
}

type stdEncoder struct {
	buf *bytes.Buffer
}

func (se stdEncoder) stdSetKV(key string, val interface{}) {
	se.buf.WriteString(Separator)
	if key == "" {
		key = "_"
	}
	se.buf.WriteString(key)
	se.buf.WriteString(AssignmentChar)
	se.buf.WriteString(fmt.Sprintf("%#v", val))
}

func (se stdEncoder) AddBool(k string, v bool) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddFloat64(k string, v float64) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddInt(k string, v int) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddInt64(k string, v int64) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddMarshaler(k string, v LogMarshaler) error {
	// se.stdSetKV( k, v.)
	return nil
}
func (se stdEncoder) AddObject(k string, v interface{}) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddString(k string, v string) {
	se.stdSetKV(k, v)
}

// AssignmentChar represents the assignment character between key-value pairs
var AssignmentChar = ": "

// Separator is the separator to use between key value pairs
var Separator = " "

func stdFormat(msg string, fs Fields) string {
	buf := bufferpool.Get()
	defer bufferpool.Put(buf)
	se := stdEncoder{buf}

	buf.WriteString(msg)
	if err := fs.AddTo(se); err != nil {
		buf.WriteString("Error")
		buf.WriteString(AssignmentChar)
		buf.WriteString(errors.PrintLoc(err))
	}
	buf.WriteRune('\n')
	return buf.String()
}

// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package store

import (
	"sync"

	"github.com/corestoreio/csfw/storage/dbr"
	"github.com/corestoreio/csfw/store/scope"
	"github.com/corestoreio/csfw/util/errors"
)

type (
	// Provider specifies a store Service from which you can only read.
	// A Getter is bound to a scope.Scope.
	Provider interface {
		IsSingleStoreMode() bool
		HasSingleStore() bool
		Website(r ...scope.WebsiteIDer) (*Website, error)
		Websites() (WebsiteSlice, error)
		Group(r ...scope.GroupIDer) (*Group, error)
		Groups() (GroupSlice, error)
		Store(r ...scope.StoreIDer) (*Store, error)
		Stores() (StoreSlice, error)

		// DefaultStoreView because a Getter is bound to a specific scope.Scope,
		// this function will return always the default store view depending on
		// the scope.
		DefaultStoreView() (*Store, error)

		// RequestedStore figures out the default active store for a scope.Option.
		// It takes into account that Getter is bound to a specific scope.Scope.
		// It also prevents running a store from another website or store group,
		// if website or store group was specified explicitly. RequestedStore returns
		// either an error or the store.
		RequestedStore(scope.Option) (activeStore *Store, err error)
	}
)

type (
	// Service represents type which handles the underlying storage and takes care
	// of the default stores. A Service is bound a specific scope.Scope. Depending
	// on the scope it is possible or not to switch stores. A Service contains also
	// a config.Getter which gets passed to the scope of a Store(), Group() or
	// Website() so that you always have the possibility to access a scoped based
	// configuration value.
	// This Service uses three internal maps to cache the pointers
	// of Website, Group and Store.
	Service struct {

		// to which scope is this current Service bound to
		boundToScope scope.Scope

		// storage get set of websites, groups and stores and also type assertion to StorageMutator for
		// ReInit and Persisting
		storage Storager

		// internal data and cached in the maps
		websites WebsiteSlice
		groups   GroupSlice
		stores   StoreSlice

		// the next six fields are for internal caching
		// map key is a hash value which is generated by either an int64 or a string.
		// maybe we can get rid of the map by using the existing slices?
		mu         sync.RWMutex
		websiteMap map[uint32]*Website
		groupMap   map[uint32]*Group
		storeMap   map[uint32]*Store

		// appStore (*cough*) contains the current selected store from init func. Cannot be cleared
		// when booting the app. This store is the main store under which the app runs.
		// In Magento slang it is called currentStore but current Store relates to a Store set
		// by InitByRequest()
		appStore *Store

		// defaultStore someone must be always the default guy.
		defaultStore *Store
	}
)

// NewService creates a new store Service which handles websites, groups and stores.
// A Service can only act on a certain scope (MAGE_RUN_TYPE) and scope ID (MAGE_RUN_CODE).
// Default scope.Scope is always the scope.WebsiteID constant.
// This function is mainly used when booting the app to set the environment configuration
// Also all other calls to any method receiver with nil arguments depends on the internal
// appStore which reflects the default store ID.
func NewService(so scope.Option, st Storager) (*Service, error) {
	scopeID := so.Scope()
	if scopeID == scope.Default {
		scopeID = scope.Website
	}

	s := &Service{
		boundToScope: scopeID,
		storage:      st,
		websiteMap:   make(map[uint32]*Website),
		groupMap:     make(map[uint32]*Group),
		storeMap:     make(map[uint32]*Store),
	}

	var err error
	s.appStore, err = s.findDefaultStoreByScope(s.boundToScope, so)
	if err != nil {
		return nil, errors.Wrap(err, "[store] NewService.findDefaultStoreByScope")
	}
	return s, nil
}

// MustNewService same as NewService, but panics on error.
func MustNewService(so scope.Option, st Storager) *Service {
	m, err := NewService(so, st)
	if err != nil {
		panic(err)
	}
	return m
}

// findDefaultStoreByScope tries to detect the default store by a given scope option.
// Precedence of detection by passed scope.Option: 1. Store 2. Group 3. Website
func (sm *Service) findDefaultStoreByScope(allowedScope scope.Scope, so scope.Option) (*Store, error) {

	switch allowedScope {
	case scope.Store:
		return sm.Store(so.Store)

	case scope.Group:
		g, errG := sm.Group(so.Group)
		if errG != nil {
			return nil, errors.Wrapf(errG, "[store] sm.Group ScopeOption %s", so)
		}
		store, err := sm.Store(g) // Group g implements StoreIDer interface to get the default store ID
		if err != nil {
			return nil, errors.NewNotFoundf(errGroupDefaultStoreNotFound)
		}
		return store, nil

	case scope.Website:
		if so.Website == nil { // if so.Website == nil then search default website
			store, err := sm.storage.DefaultStoreView() // returns a Store containing less data
			if err == nil {
				store, err = sm.Store(store) // this Store contains more data
			}
			return store, errors.Wrapf(err, "[store] DefaultStoreView Store. ScopeOption %s", so)
		}

		w, errW := sm.Website(so.Website)
		if errW != nil {
			return nil, errors.Wrapf(errW, "[store] sm.Website ScopeOption %s", so)
		}
		g, errG := w.DefaultGroup()
		if errG != nil {
			return nil, errors.Wrapf(errG, "[store] Website.DefaultGroup ScopeOption %s", so)
		}
		store, err := sm.Store(g) // Group g implements StoreIDer interface to get the default store ID
		if err != nil {
			return nil, errors.NewNotFoundf(errGroupDefaultStoreNotFound)
		}
		return store, nil
	}
	return nil, errors.NewNotSupportedf("[store] Unknown Scope: %q", allowedScope)
}

// RequestedStore see interface description Getter.RequestedStore.
// Error behaviour: Unauthorized, NotFound, NotSupported
func (sm *Service) RequestedStore(so scope.Option) (activeStore *Store, err error) {

	activeStore, err = sm.findDefaultStoreByScope(so.Scope(), so)
	if err != nil {
		return nil, errors.Wrap(err, "[store] findDefaultStoreByScope")
	}

	//	activeStore, err = sm.newActiveStore(activeStore) // this is the active store from a request.
	// todo rethink here if we really need a newActiveStore
	// newActiveStore creates a new Store, Website and Group pointers !!!
	//	if activeStore == nil || err != nil {
	//		// store is not active so ignore
	//		return nil, err
	//	}

	if false == activeStore.Data.IsActive {
		return nil, errors.NewUnauthorizedf(errStoreNotActive)
	}

	allowStoreChange := false
	switch sm.boundToScope {
	case scope.Store:
		allowStoreChange = true
		break
	case scope.Group:
		allowStoreChange = activeStore.Data.GroupID == sm.appStore.Data.GroupID
		break
	case scope.Website:
		allowStoreChange = activeStore.Data.WebsiteID == sm.appStore.Data.WebsiteID
		break
	}

	if allowStoreChange {
		return activeStore, nil
	}
	return nil, errors.NewUnauthorizedf(errStoreChangeNotAllowed)
}

// IsSingleStoreMode check if Single-Store mode is enabled in configuration and from Store count < 3.
// This flag only shows that admin does not want to show certain UI components at backend (like store switchers etc)
// if Magento has only one store view but it does not check the store view collection.
func (sm *Service) IsSingleStoreMode() bool {
	// refactor and remove dependency to backend.Backend
	return sm.HasSingleStore() // && backend.Backend.GeneralSingleStoreModeEnabled.Get(sm.cr.NewScoped(0, 0)) // default scope
}

// HasSingleStore checks if we only have one store view besides the admin store view.
// Mostly used in models to the set store id and in blocks to not display the store switch.
func (sm *Service) HasSingleStore() bool {
	ss, err := sm.Stores()
	if err != nil {
		return false
	}
	// that means: index 0 is admin store and always present plus one more store view.
	return ss.Len() < 3
}

// Website returns the cached Website pointer from an ID or code including all of its
// groups and all related stores. It panics when the integrity is incorrect.
// If ID and code are available then the non-empty code has precedence.
// If no argument has been supplied then the Website of the internal appStore
// will be returned. If more than one argument has been provided it returns an error.
func (sm *Service) Website(ids ...scope.WebsiteIDer) (*Website, error) {
	lIDs := len(ids)
	isEmptyIDs := lIDs == 0 || (lIDs == 1 && ids[0] == nil) || lIDs > 1

	if isEmptyIDs {
		return sm.appStore.Website, nil
	}

	key := scope.Option{Website: ids[0]}.ToUint32()

	if w := sm.website(key); w != nil {
		return w, nil
	}

	sm.mu.Lock()
	w, err := sm.storage.Website(ids[0])
	sm.websiteMap[key] = w
	sm.mu.Unlock()

	return w, errors.Wrap(err, "[store] Service.storage.Website")
}

// website retrieves a *Website from the internal map cache. Can return nil.
func (sm *Service) website(key uint32) *Website {
	sm.mu.RLock()
	w, ok := sm.websiteMap[key]
	sm.mu.RUnlock()
	if ok {
		return w
	}
	return nil
}

// Websites returns a cached slice containing all pointers to Websites with its associated
// groups and stores. It panics when the integrity is incorrect.
func (sm *Service) Websites() (_ WebsiteSlice, err error) {
	if sm.websites != nil {
		return sm.websites, nil
	}
	sm.websites, err = sm.storage.Websites()
	return sm.websites, errors.Wrap(err, "[store] Service.storage.Websites")
}

// Group returns a cached Group which contains all related stores and its website.
// Only the argument ID is supported.
// If no argument has been supplied then the Group of the internal appStore
// will be returned. If more than one argument has been provided it returns an error.
func (sm *Service) Group(ids ...scope.GroupIDer) (*Group, error) {
	lIDs := len(ids)
	isEmptyIDs := lIDs == 0 || (lIDs == 1 && ids[0] == nil) || lIDs > 1

	if isEmptyIDs {
		return sm.appStore.Group, nil
	}

	key := scope.Option{Group: ids[0]}.ToUint32()

	if g := sm.group(key); g != nil {
		return g, nil
	}

	sm.mu.Lock()
	g, err := sm.storage.Group(ids[0])
	sm.groupMap[key] = g
	sm.mu.Unlock()

	return g, errors.Wrap(err, "[store] Service.storage.Group")
}

// group returns a *Group from the internal map cache. Can return nil.
func (sm *Service) group(key uint32) *Group {
	sm.mu.RLock()
	g, ok := sm.groupMap[key]
	sm.mu.RUnlock()
	if ok {
		return g
	}
	return nil
}

// Groups returns a cached slice containing all pointers to Groups with its associated
// stores and websites. It panics when the integrity is incorrect.
func (sm *Service) Groups() (_ GroupSlice, err error) {
	if sm.groups != nil {
		return sm.groups, nil
	}
	sm.groups, err = sm.storage.Groups()
	return sm.groups, errors.Wrap(err, "[store] Service.storage.Groups")
}

// Store returns the cached Store view containing its group and its website.
// If ID and code are available then the non-empty code has precedence.
// If no argument has been supplied then the appStore
// will be returned. If more than one argument has been provided it returns an error.
func (sm *Service) Store(ids ...scope.StoreIDer) (*Store, error) {
	lIDs := len(ids)
	isEmptyIDs := lIDs == 0 || (lIDs == 1 && ids[0] == nil) || lIDs > 1

	if isEmptyIDs {
		return sm.appStore, nil
	}

	key := scope.Option{Store: ids[0]}.ToUint32()

	if s := sm.store(key); s != nil {
		return s, nil
	}

	sm.mu.Lock()
	s, err := sm.storage.Store(ids[0])
	sm.storeMap[key] = s
	sm.mu.Unlock()

	return s, errors.Wrap(err, "[store] Service.storage.Store")
}

// store returns a *Store from the internal map cache. Can return nil.
func (sm *Service) store(key uint32) *Store {
	sm.mu.RLock()
	s, ok := sm.storeMap[key]
	sm.mu.RUnlock()
	if ok {
		return s
	}
	return nil
}

// Stores returns a cached Store slice. Can return an error when the website or
// the group cannot be found.
func (sm *Service) Stores() (_ StoreSlice, err error) {
	if sm.stores != nil {
		return sm.stores, nil
	}
	sm.stores, err = sm.storage.Stores()
	return sm.stores, errors.Wrap(err, "[store] Service.storage.Stores")
}

// DefaultStoreView returns the default store view, independent of the
// applied scope.Option while creating the service.
func (sm *Service) DefaultStoreView() (_ *Store, err error) {
	if sm.defaultStore != nil {
		return sm.defaultStore, nil
	}
	sm.defaultStore, err = sm.storage.DefaultStoreView()
	return sm.defaultStore, errors.Wrap(err, "[store] Service.storage.DefaultStoreView")
}

// ReInit reloads the website, store group and store view data from the database.
// After reloading internal cache will be cleared if there are no errors.
func (sm *Service) ReInit(dbrSess dbr.SessionRunner, cbs ...dbr.SelectCb) error {
	err := sm.storage.ReInit(dbrSess, cbs...)
	if err == nil {
		sm.ClearCache()
	}
	return errors.Wrap(err, "[store] ReInit")
}

// ClearCache resets the internal caches which stores the pointers to a Website, Group or Store and
// all related slices. Please use with caution. ReInit() also uses this method.
// Providing argument true clears also the internal appStore cache.
func (sm *Service) ClearCache(clearAll ...bool) {
	sm.mu.Lock()
	defer sm.mu.Unlock()
	if len(sm.websiteMap) > 0 {
		for k := range sm.websiteMap {
			delete(sm.websiteMap, k)
		}
	}
	if len(sm.groupMap) > 0 {
		for k := range sm.groupMap {
			delete(sm.groupMap, k)
		}
	}
	if len(sm.storeMap) > 0 {
		for k := range sm.storeMap {
			delete(sm.storeMap, k)
		}
	}
	sm.websites = nil
	sm.groups = nil
	sm.stores = nil
	sm.defaultStore = nil
	// do not clear currentStore as this one depends on the init funcs
	if 1 == len(clearAll) && clearAll[0] {
		sm.appStore = nil
	}
}

// IsCacheEmpty returns true if the internal cache is empty.
func (sm *Service) IsCacheEmpty() bool {
	return len(sm.websiteMap) == 0 && len(sm.groupMap) == 0 && len(sm.storeMap) == 0 &&
		sm.websites == nil && sm.groups == nil && sm.stores == nil && sm.defaultStore == nil
}

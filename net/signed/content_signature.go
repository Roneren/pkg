// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package signed

import (
	"bytes"
	"net/http"

	"github.com/corestoreio/csfw/util/bufferpool"
	"github.com/corestoreio/csfw/util/errors"
)

const signatureDefaultSeparator = ','

// Signature represents an HTTP Header or Trailer entry.
type Signature struct {
	EncodeFn
	DecodeFn
	// KeyID field is an opaque string that the server/client can use to look up
	// the component they need to validate the signature. It could be an SSH key
	// fingerprint, an LDAP DN, etc. REQUIRED.
	KeyID string
	// Algorithm parameter is used if the client and server agree on a
	// non-standard digital signature algorithm.  The full list of supported
	// signature mechanisms is listed below. REQUIRED.
	Algorithm string

	// Separator defines the field separator and defaults to colon.
	Separator rune
	// HeaderKey optional field name, defaults to constant ContentSignature
	HeaderKey string
}

// Write writes the content signature header using an
// encoder, which can be hex or base64.
//
// Signature parameter is an encoded digital signature generated by the
// client.  The client uses the `algorithm` and `headers` request parameters
// to form a canonicalized `signing string`.  This `signing string` is then
// signed with the key associated with `keyId` and the algorithm
// corresponding to `algorithm`.  The `signature` parameter is then set to
// the encoding of the signature.
//
// 	Content-Signature: keyId="rsa-key-1",algorithm="rsa-sha256",signature="Hex|Base64(RSA-SHA256(signing string))"
// 	Content-Signature: keyId="hmac-key-1",algorithm="hmac-sha1",signature="Hex|Base64(HMAC-SHA1(signing string))"
func (s *Signature) Write(w http.ResponseWriter, signature []byte) {
	if s.Separator == 0 {
		s.Separator = signatureDefaultSeparator
	}
	k := ContentSignature
	if s.HeaderKey != "" {
		k = s.HeaderKey
	}
	buf := bufferpool.Get()
	buf.WriteString(`keyId="` + s.KeyID + `"`)
	buf.WriteRune(s.Separator)
	buf.WriteString(`algorithm="` + s.Algorithm + `"`)
	buf.WriteRune(s.Separator)
	buf.WriteString(`signature="`)
	buf.WriteString(s.EncodeFn(signature))
	buf.WriteRune('"')
	w.Header().Set(k, buf.String())
	bufferpool.Put(buf)
}

// Parse parses the header or trailer Content-Signature into the struct.
// Returns an error notFound, notValid behaviour or nil on success.
func (s *Signature) Parse(r *http.Request) (signature []byte, err error) {
	if s.Separator == 0 {
		s.Separator = signatureDefaultSeparator
	}
	k := ContentSignature
	if s.HeaderKey != "" {
		k = s.HeaderKey
	}
	headerVal := r.Header.Get(k)
	if headerVal == "" {
		headerVal = r.Trailer.Get(k)
	}
	if headerVal == "" {
		return nil, errors.NewNotFoundf("[signed] Signature not found or empty")
	}

	// keyId="hmac-key-1",algorithm="hmac-sha1",signature="Hex|Base64(HMAC-SHA1(signing string))"

	var fields [3]bytes.Buffer
	var idx int
	for _, r := range headerVal {
		if r == s.Separator {
			idx++
			continue
		}
		if idx > 2 { // too many separators
			return nil, errors.NewNotValidf("[signed] Invalid signature header: %q", headerVal)
		}
		fields[idx].WriteRune(r)
	}
	if idx < 2 { // too less separators
		return nil, errors.NewNotValidf("[signed] Invalid signature header: %q", headerVal)
	}

	// trim first and last white spaces
	for i := 0; i < 3; i++ {
		tmp := fields[i].Bytes()
		fields[i].Reset()
		_, _ = fields[i].Write(bytes.TrimSpace(tmp))
	}

	// check min length
	switch {
	case fields[0].Len() < 8: // keyId="" but empty keyId allowed
		return nil, errors.NewNotValidf("[signed] Invalid length for keyId %q in header: %q", fields[0].String(), headerVal)
	case fields[1].Len() <= 12: // algorithm=""
		return nil, errors.NewNotValidf("[signed] Invalid length for algorithm %q in header: %q", fields[1].String(), headerVal)
	case fields[2].Len() <= 12: // signature=""
		return nil, errors.NewNotValidf("[signed] Invalid length for signature %q in header: %q", fields[2].String(), headerVal)
	}

	// keyID not yet used ...

	// check for valid algorithm
	if haveAlg := fields[1].String()[11 : fields[1].Len()-1]; s.Algorithm != haveAlg || s.Algorithm == "" {
		return nil, errors.NewNotValidf("[signed] Algorithm %q does not match required %q in header: %q", haveAlg, s.Algorithm, headerVal)
	}

	rawSig := fields[2].String()[11 : fields[2].Len()-1]
	dec, err := s.DecodeFn(rawSig)
	if err != nil {
		return nil, errors.Wrapf(err, "[signed] failed to decode: %q in header %q", rawSig, headerVal)
	}
	return dec, nil
}

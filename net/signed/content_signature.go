// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package signed

import (
	"bytes"
	"encoding/hex"
	"net/http"

	"github.com/corestoreio/csfw/util/bufferpool"
	"github.com/corestoreio/csfw/util/errors"
)

const signatureDefaultSeparator = ','

// Signature represents an HTTP Header or Trailer entry with the default header
// key Content-Signature.
type Signature struct {
	// KeyID field is an opaque string that the server/client can use to look up
	// the component they need to validate the signature. It could be an SSH key
	// fingerprint, an LDAP DN, etc. REQUIRED.
	KeyID string

	// Separator defines the field separator and defaults to colon.
	Separator rune

	HMAC
}

// NewSignature creates a new header signature object with default hex
// encoding/decoding to write and parse the Content-Signature field.
func NewSignature(keyID, algorithm string) *Signature {
	return &Signature{
		KeyID: keyID,
		HMAC: HMAC{
			Algorithm: algorithm,
		},
	}
}

// HeaderKey returns the name of the header key
func (s *Signature) HeaderKey() string {
	if s.HeaderName != "" {
		return s.HeaderName
	}
	return ContentSignature
}

// Write writes the content signature header using an
// encoder, which can be hex or base64.
//
// Signature parameter is an encoded digital signature generated by the
// client.  The client uses the `algorithm` and `headers` request parameters
// to form a canonicalized `signing string`.  This `signing string` is then
// signed with the key associated with `keyId` and the algorithm
// corresponding to `algorithm`.  The `signature` parameter is then set to
// the encoding of the signature.
//
// 	Content-Signature: keyId="rsa-key-1",algorithm="rsa-sha256",signature="Hex|Base64(RSA-SHA256(signing string))"
// 	Content-Signature: keyId="hmac-key-1",algorithm="hmac-sha1",signature="Hex|Base64(HMAC-SHA1(signing string))"
func (s *Signature) Write(w http.ResponseWriter, signature []byte) {
	if s.Separator == 0 {
		s.Separator = signatureDefaultSeparator
	}

	encFn := s.EncodeFn
	if encFn == nil {
		encFn = hex.EncodeToString
	}
	buf := bufferpool.Get()
	_, _ = buf.WriteString(`keyId="` + s.KeyID + `"`)
	_, _ = buf.WriteRune(s.Separator)
	_, _ = buf.WriteString(`algorithm="` + s.Algorithm + `"`)
	_, _ = buf.WriteRune(s.Separator)
	_, _ = buf.WriteString(`signature="`)
	_, _ = buf.WriteString(encFn(signature))
	_, _ = buf.WriteRune('"')
	w.Header().Set(s.HeaderKey(), buf.String())
	bufferpool.Put(buf)
}

// Parse looks up the header or trailer for the HeaderKey Content-Signature in an
// HTTP request and extracts the raw decoded signature. Errors can have the
// behaviour: NotFound or NotValid.
func (s *Signature) Parse(r *http.Request) (signature []byte, _ error) {
	if s.Separator == 0 {
		s.Separator = signatureDefaultSeparator
	}
	k := s.HeaderKey()
	headerVal := r.Header.Get(k)
	if headerVal == "" {
		headerVal = r.Trailer.Get(k)
	}
	if headerVal == "" {
		return nil, errors.NewNotFoundf("[signed] Signature not found or empty")
	}

	// keyId="hmac-key-1",algorithm="hmac-sha1",signature="Hex|Base64(HMAC-SHA1(signing string))"

	var fields [3]bytes.Buffer
	var idx int
	for _, r := range headerVal {
		if r == s.Separator {
			idx++
			continue
		}
		if idx > 2 { // too many separators
			return nil, errors.NewNotValidf("[signed] Invalid signature header: %q", headerVal)
		}
		_, _ = fields[idx].WriteRune(r)
	}
	if idx < 2 { // too less separators
		return nil, errors.NewNotValidf("[signed] Invalid signature header: %q", headerVal)
	}

	// trim first and last white spaces
	for i := 0; i < 3; i++ {
		tmp := fields[i].Bytes()
		fields[i].Reset()
		_, _ = fields[i].Write(bytes.TrimSpace(tmp))
	}

	// check min length
	switch {
	case fields[0].Len() <= 8: // keyId="" but empty keyId allowed
		return nil, errors.NewNotValidf("[signed] Invalid length for keyId %q in header: %q", fields[0].String(), headerVal)
	case fields[1].Len() <= 12: // algorithm=""
		return nil, errors.NewNotValidf("[signed] Invalid length for algorithm %q in header: %q", fields[1].String(), headerVal)
	case fields[2].Len() <= 12: // signature=""
		return nil, errors.NewNotValidf("[signed] Invalid length for signature %q in header: %q", fields[2].String(), headerVal)
	}

	// check for valid keyID
	if haveKeyID := fields[0].String()[7 : fields[0].Len()-1]; s.KeyID != haveKeyID || s.KeyID == "" {
		return nil, errors.NewNotValidf("[signed] KeyID %q does not match required %q in header: %q", haveKeyID, s.KeyID, headerVal)
	}

	// check for valid algorithm
	if haveAlg := fields[1].String()[11 : fields[1].Len()-1]; s.Algorithm != haveAlg || s.Algorithm == "" {
		return nil, errors.NewNotValidf("[signed] Algorithm %q does not match required %q in header: %q", haveAlg, s.Algorithm, headerVal)
	}

	decFn := s.DecodeFn
	if decFn == nil {
		decFn = hex.DecodeString
	}
	rawSig := fields[2].String()[11 : fields[2].Len()-1]
	dec, err := decFn(rawSig)
	if err != nil {
		// micro optimization: skip argument building
		return nil, errors.Wrapf(err, "[signed] failed to decode: %q in header %q", rawSig, headerVal)
	}
	return dec, nil
}
